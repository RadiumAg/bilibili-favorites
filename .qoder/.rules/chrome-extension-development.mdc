---
description: 
alwaysApply: true
enabled: true
updatedAt: 2025-11-20T14:40:28.373Z
provider: 
---

# Chrome扩展开发规范

## Manifest V3配置

### 基础配置
```typescript
// src/manifest.ts
import { defineManifest } from '@crxjs/vite-plugin'
import packageData from '../package.json'

const isDev = process.env.NODE_ENV === 'development'

export default defineManifest({
  name: `${packageData.displayName || packageData.name}${isDev ? ' ➡️ Dev' : ''}`,
  description: packageData.description,
  version: packageData.version,
  manifest_version: 3,
  
  // 图标配置
  icons: {
    16: 'img/logo-16.png',
    32: 'img/logo-34.png',
    48: 'img/logo-48.png',
    128: 'img/logo-128.png',
  },
  
  // 扩展操作
  action: {
    default_popup: 'popup.html',
    default_icon: 'img/logo-48.png',
  },
  
  // 后台脚本
  background: {
    service_worker: 'src/background/index.ts',
    type: 'module',
  },
  
  // 内容脚本
  content_scripts: [
    {
      matches: ['*://*.bilibili.com/*'],
      js: ['src/contentScript/index.ts'],
      run_at: 'document_end'
    }
  ],
  
  // Web可访问资源
  web_accessible_resources: [
    {
      resources: ['img/*.png'],
      matches: ['*://*.bilibili.com/*']
    }
  ],
  
  // 权限配置
  permissions: [
    'storage',
    'activeTab'
  ],
  
  // 可选权限
  optional_permissions: [
    'background',
    'scripting'
  ],
  
  // 选项页面
  options_ui: {
    page: 'options.html',
    open_in_tab: true,
  },
  
  // 内容安全策略
  content_security_policy: {
    extension_pages: "script-src 'self'; object-src 'self'"
  }
})
```

### 权限管理原则
- **最小权限原则**: 只申请必要的权限
- **可选权限**: 非核心功能使用可选权限
- **用户透明**: 向用户清楚说明每个权限的用途
- **渐进式权限**: 根据功能需要动态申请权限

## 架构设计

### 扩展架构图
```mermaid
graph TD
    A[用户界面] --> B[Popup Script]
    A --> C[Options Page]
    A --> D[Content Script]
    
    B --> E[Background Script]
    C --> E
    D --> E
    
    E --> F[Chrome APIs]
    E --> G[外部API]
    
    F --> H[Storage API]
    F --> I[Messaging API]
    F --> J[Tabs API]
```

### 目录结构
```
src/
├── background/              # 后台脚本
│   ├── index.ts            # 主入口
│   ├── handlers/           # 消息处理器
│   └── schedulers/         # 定时任务
├── contentScript/          # 内容脚本
│   ├── index.ts           # 主入口
│   ├── injectors/         # 页面注入
│   └── observers/         # DOM监听
├── popup/                 # 弹出窗口
│   ├── index.tsx          # 入口组件
│   ├── Popup.tsx          # 主组件
│   └── components/        # 弹窗专用组件
├── options/               # 选项页面
│   ├── index.tsx          # 入口组件
│   ├── Options.tsx        # 主组件
│   └── components/        # 选项页专用组件
├── shared/                # 共享代码
│   ├── types/            # 类型定义
│   ├── utils/            # 工具函数
│   └── constants/        # 常量定义
└── assets/               # 静态资源
    ├── img/              # 图片资源
    └── css/              # 样式文件
```

## 消息通信规范

### 消息类型定义
```typescript
// src/shared/types/messages.ts
export enum MessageType {
  // 收藏夹相关
  GET_FAVORITE_LIST = 'GET_FAVORITE_LIST',
  GET_FAVORITE_RESOURCES = 'GET_FAVORITE_RESOURCES',
  UPDATE_FAVORITE = 'UPDATE_FAVORITE',
  
  // AI分析相关
  ANALYZE_CONTENT = 'ANALYZE_CONTENT',
  EXTRACT_KEYWORDS = 'EXTRACT_KEYWORDS',
  
  // 存储相关
  SAVE_SETTINGS = 'SAVE_SETTINGS',
  LOAD_SETTINGS = 'LOAD_SETTINGS',
  
  // 页面交互
  PAGE_READY = 'PAGE_READY',
  INJECT_SCRIPT = 'INJECT_SCRIPT'
}

export interface BaseMessage {
  type: MessageType
  id: string
  timestamp: number
}

export interface RequestMessage<T = any> extends BaseMessage {
  payload: T
}

export interface ResponseMessage<T = any> extends BaseMessage {
  success: boolean
  data?: T
  error?: string
}
```

### 消息发送器
```typescript
// src/shared/utils/messaging.ts
export class MessageSender {
  private static generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  }
  
  // 发送消息到Background Script
  static async sendToBackground<T = any, R = any>(
    type: MessageType,
    payload?: T
  ): Promise<R> {
    return new Promise((resolve, reject) => {
      const message: RequestMessage<T> = {
        type,
        payload: payload as T,
        id: MessageSender.generateId(),
        timestamp: Date.now()
      }
      
      chrome.runtime.sendMessage(message, (response: ResponseMessage<R>) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message))
        } else if (!response.success) {
          reject(new Error(response.error || 'Unknown error'))
        } else {
          resolve(response.data!)
        }
      })
    })
  }
  
  // 发送消息到Content Script
  static async sendToContentScript<T = any, R = any>(
    tabId: number,
    type: MessageType,
    payload?: T
  ): Promise<R> {
    return new Promise((resolve, reject) => {
      const message: RequestMessage<T> = {
        type,
        payload: payload as T,
        id: MessageSender.generateId(),
        timestamp: Date.now()
      }
      
      chrome.tabs.sendMessage(tabId, message, (response: ResponseMessage<R>) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message))
        } else if (!response.success) {
          reject(new Error(response.error || 'Unknown error'))
        } else {
          resolve(response.data!)
        }
      })
    })
  }
}
```

### 消息处理器
```typescript
// src/background/handlers/messageHandler.ts
export class MessageHandler {
  private handlers = new Map<MessageType, Function>()
  
  constructor() {
    this.registerHandlers()
    this.setupListener()
  }
  
  private registerHandlers(): void {
    this.handlers.set(MessageType.GET_FAVORITE_LIST, this.handleGetFavoriteList)
    this.handlers.set(MessageType.ANALYZE_CONTENT, this.handleAnalyzeContent)
    this.handlers.set(MessageType.SAVE_SETTINGS, this.handleSaveSettings)
  }
  
  private setupListener(): void {
    chrome.runtime.onMessage.addListener(
      (message: RequestMessage, sender, sendResponse) => {
        const handler = this.handlers.get(message.type)
        
        if (handler) {
          // 异步处理需要返回true
          handler.call(this, message.payload, sender)
            .then(data => {
              sendResponse({
                ...message,
                success: true,
                data
              })
            })
            .catch(error => {
              sendResponse({
                ...message,
                success: false,
                error: error.message
              })
            })
          
          return true
        }
        
        sendResponse({
          ...message,
          success: false,
          error: 'Unknown message type'
        })
      }
    )
  }
  
  private async handleGetFavoriteList(payload: any): Promise<any> {
    // 处理获取收藏夹列表逻辑
  }
  
  private async handleAnalyzeContent(payload: any): Promise<any> {
    // 处理AI分析逻辑
  }
}
```

## 存储管理规范

### 存储抽象层
```typescript
// src/shared/utils/storage.ts
export interface StorageItem {
  value: any
  timestamp: number
  ttl?: number // 生存时间（毫秒）
}

export class StorageManager {
  private static instance: StorageManager
  private memoryCache = new Map<string, any>()
  
  static getInstance(): StorageManager {
    if (!StorageManager.instance) {
      StorageManager.instance = new StorageManager()
    }
    return StorageManager.instance
  }
  
  // 设置数据
  async set<T>(key: string, value: T, ttl?: number): Promise<void> {
    const item: StorageItem = {
      value,
      timestamp: Date.now(),
      ttl
    }
    
    // 同时存储到内存缓存和Chrome存储
    this.memoryCache.set(key, value)
    
    await chrome.storage.local.set({
      [key]: item
    })
  }
  
  // 获取数据
  async get<T>(key: string): Promise<T | null> {
    // 先检查内存缓存
    if (this.memoryCache.has(key)) {
      return this.memoryCache.get(key)
    }
    
    // 从Chrome存储获取
    const result = await chrome.storage.local.get(key)
    const item: StorageItem = result[key]
    
    if (!item) {
      return null
    }
    
    // 检查是否过期
    if (item.ttl && Date.now() - item.timestamp > item.ttl) {
      await this.remove(key)
      return null
    }
    
    // 更新内存缓存
    this.memoryCache.set(key, item.value)
    
    return item.value
  }
  
  // 移除数据
  async remove(key: string): Promise<void> {
    this.memoryCache.delete(key)
    await chrome.storage.local.remove(key)
  }
  
  // 清空所有数据
  async clear(): Promise<void> {
    this.memoryCache.clear()
    await chrome.storage.local.clear()
  }
  
  // 获取所有键
  async getAllKeys(): Promise<string[]> {
    const items = await chrome.storage.local.get(null)
    return Object.keys(items).filter(key => {
      const item: StorageItem = items[key]
      return !item.ttl || Date.now() - item.timestamp <= item.ttl
    })
  }
}

export const storage = StorageManager.getInstance()
```

### 数据模型定义
```typescript
// src/shared/types/storage.ts
export interface UserSettings {
  // API配置
  openaiApiKey?: string
  bilibiliCookie?: string
  
  // 功能开关
  enableAutoAnalysis: boolean
  enableSmartCategorization: boolean
  
  // 界面设置
  theme: 'light' | 'dark'
  language: 'zh-CN' | 'en-US'
  
  // 其他配置
  maxFavoritesPerPage: number
  autoBackup: boolean
}

export interface FavoriteCache {
  folders: FavoriteFolder[]
  resources: Record<string, FavoriteResource[]>
  lastUpdated: number
}

export interface AnalysisResult {
  id: string
  type: 'keyword' | 'category' | 'trend'
  data: any
  createdAt: number
}
```

## Content Script规范

### 页面注入管理
```typescript
// src/contentScript/index.ts
export class ContentScriptManager {
  private isPageReady = false
  private observers: MutationObserver[] = []
  
  constructor() {
    this.init()
  }
  
  private async init(): Promise<void> {
    // 等待页面加载完成
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.onPageReady())
    } else {
      this.onPageReady()
    }
  }
  
  private onPageReady(): void {
    this.isPageReady = true
    this.setupMessageListener()
    this.observePageChanges()
    this.injectUI()
    
    // 通知Background Script页面已准备
    MessageSender.sendToBackground(MessageType.PAGE_READY)
  }
  
  private setupMessageListener(): void {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      this.handleMessage(message)
        .then(data => sendResponse({ success: true, data }))
        .catch(error => sendResponse({ success: false, error: error.message }))
      
      return true
    })
  }
  
  private async handleMessage(message: RequestMessage): Promise<any> {
    switch (message.type) {
      case MessageType.INJECT_SCRIPT:
        return this.injectScript(message.payload)
      default:
        throw new Error('Unknown message type')
    }
  }
  
  private observePageChanges(): void {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          this.handleDOMChange(mutation)
        }
      })
    })
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    })
    
    this.observers.push(observer)
  }
  
  private handleDOMChange(mutation: MutationRecord): void {
    // 处理DOM变化逻辑
  }
  
  private injectUI(): void {
    // 注入自定义UI元素
  }
  
  private injectScript(scriptUrl: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = chrome.runtime.getURL(scriptUrl)
      script.onload = () => {
        script.remove()
        resolve()
      }
      script.onerror = () => reject(new Error('Failed to inject script'))
      document.head.appendChild(script)
    })
  }
  
  // 清理资源
  destroy(): void {
    this.observers.forEach(observer => observer.disconnect())
    this.observers = []
  }
}

// 初始化Content Script
new ContentScriptManager()
```

## 安全规范

### Content Security Policy (CSP)
```typescript
// 严格的CSP配置
const CSP_DIRECTIVES = {
  'default-src': ["'self'"],
  'script-src': ["'self'", "'unsafe-inline'"],
  'style-src': ["'self'", "'unsafe-inline'"],
  'img-src': ["'self'", 'data:', 'https:'],
  'connect-src': ["'self'", 'https://api.bilibili.com', 'https://api.openai.com'],
  'font-src': ["'self'", 'data:']
}

// 在manifest中应用
content_security_policy: {
  extension_pages: Object.entries(CSP_DIRECTIVES)
    .map(([directive, sources]) => `${directive} ${sources.join(' ')}`)
    .join('; ')
}
```

### 数据验证和清理
```typescript
// src/shared/utils/validation.ts
export class DataValidator {
  // 验证URL
  static isValidUrl(url: string): boolean {
    try {
      new URL(url)
      return true
    } catch {
      return false
    }
  }
  
  // 清理HTML内容
  static sanitizeHTML(html: string): string {
    const div = document.createElement('div')
    div.textContent = html
    return div.innerHTML
  }
  
  // 验证Bilibili视频ID
  static isValidBVID(bvid: string): boolean {
    return /^BV[0-9A-Za-z]{10}$/.test(bvid)
  }
  
  // 验证API响应
  static validateAPIResponse(response: any): boolean {
    return response && 
           typeof response.code === 'number' && 
           typeof response.message === 'string'
  }
}
```

## 性能优化

### 代码分割
```typescript
// 动态导入大型库
const loadECharts = async () => {
  const echarts = await import('echarts')
  return echarts.default
}

// 按需加载功能
const loadAnalysisFeature = async () => {
  const { AnalysisComponent } = await import('./components/Analysis')
  return AnalysisComponent
}
```

### 内存管理
```typescript
// 定期清理缓存
export class MemoryManager {
  private static readonly CLEANUP_INTERVAL = 5 * 60 * 1000 // 5分钟
  
  static startAutoCleanup(): void {
    setInterval(() => {
      this.cleanupExpiredCache()
      this.cleanupUnusedResources()
    }, MemoryManager.CLEANUP_INTERVAL)
  }
  
  private static async cleanupExpiredCache(): Promise<void> {
    const keys = await storage.getAllKeys()
    const expiredKeys = []
    
    for (const key of keys) {
      const item = await storage.get(key)
      if (item && item.ttl && Date.now() - item.timestamp > item.ttl) {
        expiredKeys.push(key)
      }
    }
    
    for (const key of expiredKeys) {
      await storage.remove(key)
    }
  }
  
  private static cleanupUnusedResources(): void {
    // 清理未使用的资源
    if (global.gc) {
      global.gc()
    }
  }
}
```

## 测试规范

### 扩展测试环境
```typescript
// tests/setup/extension.ts
import { WebExtension } from 'webextension-polyfill-ts'

// 模拟Chrome APIs
global.chrome = WebExtension as any

// 设置测试环境
beforeEach(() => {
  chrome.storage.local.clear()
  chrome.runtime.sendMessage.mockClear()
})
```

### 集成测试
```typescript
// tests/integration/favorite.test.ts
describe('Favorite Integration', () => {
  it('should get favorite list from API', async () => {
    // 模拟API响应
    jest.spyOn(api, 'getFavoriteList').mockResolvedValue(mockFavoriteList)
    
    // 发送消息到Background Script
    const result = await MessageSender.sendToBackground(
      MessageType.GET_FAVORITE_LIST,
      { vmid: '123456' }
    )
    
    expect(result).toEqual(mockFavoriteList.data)
  })
})
```