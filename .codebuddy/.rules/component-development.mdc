---
description: 
alwaysApply: true
enabled: true
updatedAt: 2025-11-20T14:38:37.469Z
provider: 
---

# 组件开发规范

## 组件设计原则

### 单一职责原则
- 每个组件只负责一个功能
- 保持组件的简洁和可维护性
- 避免过度复杂的组件逻辑

### 可复用性
- 设计通用的UI组件
- 使用props配置组件行为
- 避免硬编码，提高灵活性

### 可测试性
- 组件逻辑与UI分离
- 纯函数优先
- 便于单元测试和集成测试

## 组件文件结构

### 基础组件结构
```
components/
├── ui/                    # 基础UI组件
│   ├── Button/
│   │   ├── index.tsx      # 组件导出
│   │   ├── Button.tsx     # 主组件文件
│   │   └── Button.stories.tsx # Storybook故事（如使用）
│   └── ...
├── favorite-tag/          # 业务组件
│   ├── index.tsx          # 组件导出
│   ├── FavoriteTag.tsx    # 主组件
│   ├── types.ts           # 类型定义
│   └── utils.ts           # 组件工具函数
└── ...
```

### 导出规范
```typescript
// components/ui/Button/index.tsx
export { Button } from './Button'
export type { ButtonProps } from './Button'
```

## 组件命名规范

### 文件命名
- 组件文件使用PascalCase：`UserProfile.tsx`
- 工具文件使用camelCase：`userUtils.ts`
- 类型文件使用camelCase：`userTypes.ts`
- 测试文件使用`.test.tsx`或`.spec.tsx`后缀

### 组件命名
- 组件名使用PascalCase：`UserProfile`
- Props接口名：`UserProfileProps`
- 类型别名：`UserStatus`
- 枚举名：`UserType`

## Props设计规范

### 基础Props结构
```typescript
interface ComponentProps {
  // 必需属性
  id: string
  title: string
  
  // 可选属性
  variant?: 'primary' | 'secondary'
  size?: 'sm' | 'md' | 'lg'
  disabled?: boolean
  
  // 事件处理
  onClick?: (event: React.MouseEvent) => void
  onChange?: (value: string) => void
  
  // 子组件
  children?: React.ReactNode
  
  // 样式相关
  className?: string
  style?: React.CSSProperties
}
```

### Props设计原则
1. **明确性**: Props名称要清晰表达用途
2. **一致性**: 相似功能使用相同的Props名
3. **向后兼容**: 新增Props要有默认值
4. **类型安全**: 使用TypeScript严格类型检查

## 组件实现规范

### 函数式组件模板
```typescript
import React, { forwardRef, useMemo, useCallback } from 'react'
import { cn } from '@/utils/cn' // 假设有classnames工具

interface ComponentProps {
  // Props定义
}

export const Component = forwardRef<HTMLDivElement, ComponentProps>(
  ({ className, children, ...props }, ref) => {
    // 计算属性
    const computedValue = useMemo(() => {
      // 复杂计算逻辑
    }, [dependencies])

    // 事件处理
    const handleClick = useCallback((event: React.MouseEvent) => {
      // 处理逻辑
    }, [dependencies])

    return (
      <div
        ref={ref}
        className={cn('default-classes', className)}
        {...props}
      >
        {children}
      </div>
    )
  }
)

Component.displayName = 'Component'
```

### Hooks使用规范
```typescript
// 自定义Hook示例
const useComponentLogic = (props: ComponentProps) => {
  const [state, setState] = useState(initialState)
  
  // 副作用
  useEffect(() => {
    // 副作用逻辑
    return () => {
      // 清理逻辑
    }
  }, [dependencies])
  
  // 计算属性
  const computedValue = useMemo(() => {
    return // 计算逻辑
  }, [state, props])
  
  // 事件处理
  const handlers = useMemo(() => ({
    handleClick: () => {
      // 处理逻辑
    },
    handleChange: (value: string) => {
      // 处理逻辑
    }
  }), [dependencies])
  
  return {
    state,
    computedValue,
    handlers
  }
}
```

## 样式规范

### Tailwind CSS使用
```typescript
// 基础样式类
const baseClasses = 'flex items-center justify-center'

// 变体样式
const variants = {
  primary: 'bg-blue-500 text-white hover:bg-blue-600',
  secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300'
}

// 尺寸样式
const sizes = {
  sm: 'px-2 py-1 text-sm',
  md: 'px-4 py-2 text-base',
  lg: 'px-6 py-3 text-lg'
}

// 使用示例
<button className={cn(
  baseClasses,
  variants[variant],
  sizes[size],
  className
)}>
  {children}
</button>
```

### 响应式设计
```typescript
// 响应式类名
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  {/* 内容 */}
</div>

// 响应式Props
interface ResponsiveProps {
  cols?: {
    sm?: number
    md?: number
    lg?: number
  }
}
```

## 错误处理和边界

### Error Boundary
```typescript
import React, { Component, ErrorInfo, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  }

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo)
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback || <div>Something went wrong</div>
    }

    return this.props.children
  }
}
```

### 组件错误处理
```typescript
const Component = ({ data }: Props) => {
  if (!data) {
    return <div>No data available</div>
  }
  
  if (data.length === 0) {
    return <div>Empty state</div>
  }
  
  return <div>{/* 正常渲染 */}</div>
}
```

## 性能优化

### React.memo使用
```typescript
// 纯组件优化
export const PureComponent = React.memo(({ value, onClick }: Props) => {
  return <div onClick={onClick}>{value}</div>
}, (prevProps, nextProps) => {
  // 自定义比较逻辑
  return prevProps.value === nextProps.value
})
```

### useMemo和useCallback
```typescript
const Component = ({ items, onSelect }: Props) => {
  // 复杂计算缓存
  const expensiveValue = useMemo(() => {
    return items.reduce((sum, item) => sum + item.value, 0)
  }, [items])
  
  // 事件处理函数缓存
  const handleClick = useCallback((id: string) => {
    onSelect(id)
  }, [onSelect])
  
  return <div>{/* 渲染逻辑 */}</div>
}
```

## 测试规范

### 组件测试模板
```typescript
import { render, screen, fireEvent } from '@testing-library/react'
import { Component } from './Component'

describe('Component', () => {
  it('renders correctly', () => {
    render(<Component title="Test" />)
    expect(screen.getByText('Test')).toBeInTheDocument()
  })
  
  it('handles click events', () => {
    const handleClick = jest.fn()
    render(<Component onClick={handleClick} />)
    
    fireEvent.click(screen.getByRole('button'))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })
})
```

## 文档规范

### 组件文档
```typescript
/**
 * 组件描述
 * 
 * @example
 * ```tsx
 * <Component title="示例" variant="primary" />
 * ```
 */
export const Component = ({ title, variant }: Props) => {
  // 组件实现
}
```

### JSDoc注释
```typescript
interface Props {
  /** 按钮标题 */
  title: string
  /** 按钮变体 */
  variant?: 'primary' | 'secondary'
  /** 点击事件处理函数 */
  onClick?: (event: React.MouseEvent) => void
}
```